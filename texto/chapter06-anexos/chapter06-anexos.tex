%% comienzo de la parte de anexos
\appendixpart

%% Anexo A: Scripts de Testing
\appendix{Scripts de Testing y Benchmarking}
\label{anexo:scripts}

\section{Script de Benchmark: test\_batch\_modes.sh}
\label{anexo:test-batch}

Este script ejecuta pruebas de rendimiento comparando los modos secuencial y paralelo del programa \texttt{batchcompare}. Mide tiempos de ejecución para diferentes configuraciones de workers.

\begin{verbatim}
#!/bin/bash

# Script de benchmark de modos secuencial y paralelo del batchcompare

echo "================================================"
echo "Benchmark BatchCompare: Secuencial vs Paralelo"
echo "================================================"

# Verificar que existe el archivo de secuencias
if [ ! -f "sec.txt" ]; then
    echo "Error: No se encuentra el archivo sec.txt"
    exit 1
fi

# Contar secuencias
NUM_SEQ=$(grep -v "^#" sec.txt | grep -v "^$" | wc -l)
NUM_COMP=$((NUM_SEQ * (NUM_SEQ - 1) / 2))

echo "Archivo: sec.txt"
echo "Secuencias: $NUM_SEQ"
echo "Comparaciones: $NUM_COMP"

# Función para medir tiempo en milisegundos
measure_time() {
    local start=$(date +%s%N)
    "$@" > /dev/null 2>&1
    local end=$(date +%s%N)
    local elapsed=$(( (end - start) / 1000000 ))
    echo $elapsed
}

# Modo SECUENCIAL
echo "=== MODO SECUENCIAL ==="
TIME_SEQ=$(measure_time ./build/batchcompare -f sec.txt -seq \
           -csv seq_stats.csv)
echo "Completado en ${TIME_SEQ}ms"

# Modo PARALELO con 2, 4, 6, 8, 10, 12 workers
for W in 2 4 6 8 10 12; do
    echo "=== MODO PARALELO ($W workers) ==="
    TIME_PAR=$(measure_time ./build/batchcompare -f sec.txt -w $W \
               -csv par${W}_stats.csv)
    echo "Completado en ${TIME_PAR}ms"
done
\end{verbatim}

\section{Generador de Secuencias: generate\_sequences.py}
\label{anexo:generate-sequences}

Script Python para generar secuencias aleatorias de aminoácidos con parámetros configurables. Utilizado para crear conjuntos de datos de prueba.

\begin{verbatim}
#!/usr/bin/env python3
"""
Generador de secuencias aleatorias de aminoácidos.
Genera secuencias usando los 20 aminoácidos estándar.
"""

import random
import argparse

# 20 aminoácidos estándar
AMINO_ACIDS = [
    "A", "C", "D", "E", "F", "G", "H", "I", "K", "L",
    "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y"
]

def generate_sequence(length, uppercase_ratio=0.5, seed=None):
    """Genera una secuencia aleatoria de aminoácidos."""
    if seed is not None:
        random.seed(seed)
    
    sequence = []
    for _ in range(length):
        aa = random.choice(AMINO_ACIDS)
        if random.random() < uppercase_ratio:
            sequence.append(aa.upper())
        else:
            sequence.append(aa.lower())
    
    return "".join(sequence)

def main():
    parser = argparse.ArgumentParser(
        description='Genera secuencias aleatorias de aminoácidos'
    )
    parser.add_argument('-n', '--num', type=int, default=10,
                       help='Número de secuencias')
    parser.add_argument('-l', '--length', type=int, default=50,
                       help='Longitud de cada secuencia')
    parser.add_argument('-u', '--uppercase', type=float, default=0.5,
                       help='Proporción de mayúsculas (0.0-1.0)')
    parser.add_argument('-o', '--output', type=str,
                       help='Archivo de salida')
    parser.add_argument('-s', '--seed', type=int,
                       help='Semilla para reproducibilidad')
    
    args = parser.parse_args()
    
    sequences = []
    for i in range(args.num):
        seq = generate_sequence(args.length, args.uppercase, 
                               args.seed)
        sequences.append(seq)
    
    if args.output:
        with open(args.output, 'w') as f:
            for seq in sequences:
                f.write(seq + '\n')
    else:
        for seq in sequences:
            print(seq)

if __name__ == "__main__":
    main()
\end{verbatim}

\section{Analizador de Resultados: analyze\_results.py}

Script para procesar y analizar los resultados de los benchmarks, calculando métricas de rendimiento y generando resúmenes estadísticos.

\begin{verbatim}
#!/usr/bin/env python3
"""
Script para analizar resultados de benchmarks
"""

import csv
import sys

def load_csv(filename):
    """Carga el CSV y devuelve los datos"""
    data = []
    with open(filename, "r") as f:
        reader = csv.DictReader(f)
        for row in reader:
            data.append({
                "Length": int(row["Length"]),
                "Seq_Total_ms": float(row["Seq_Total_ms"]),
                "Par_Total_ms": float(row["Par_Total_ms"]),
                "Speedup_Total": float(row["Speedup_Total"]),
                "Speedup_DP": float(row["Speedup_DP"]),
                "Speedup_BT": float(row["Speedup_BT"]),
                "LCS_Count": int(row["LCS_Count"])
            })
    return data

def calculate_stats(data):
    """Calcula estadísticas agregadas"""
    speedups = [row["Speedup_Total"] for row in data]
    avg_speedup = sum(speedups) / len(speedups)
    max_speedup = max(speedups)
    min_speedup = min(speedups)
    
    return {
        "avg_speedup": avg_speedup,
        "max_speedup": max_speedup,
        "min_speedup": min_speedup,
        "count": len(data)
    }

def print_results(data, stats):
    """Imprime resultados formateados"""
    print("=" * 90)
    print("RESULTADOS DEL BENCHMARK")
    print("=" * 90)
    
    for row in data:
        print(f"Length: {row['Length']:<6} | "
              f"Speedup: {row['Speedup_Total']:.2f}x | "
              f"LCS: {row['LCS_Count']}")
    
    print("\n" + "=" * 90)
    print(f"Promedio Speedup: {stats['avg_speedup']:.2f}x")
    print(f"Máximo Speedup:   {stats['max_speedup']:.2f}x")
    print(f"Mínimo Speedup:   {stats['min_speedup']:.2f}x")
    print("=" * 90)

def main():
    if len(sys.argv) < 2:
        print("Uso: python analyze_results.py <archivo.csv>")
        sys.exit(1)
    
    filename = sys.argv[1]
    data = load_csv(filename)
    stats = calculate_stats(data)
    print_results(data, stats)

if __name__ == "__main__":
    main()
\end{verbatim}


%% Anexo B: Configuración del Entorno
\appendix{Configuración del Entorno de Desarrollo}
\label{anexo:configuracion}

\section{Repositorio del Proyecto}
\label{anexo:repositorio}

El código fuente completo del proyecto está disponible públicamente en GitHub:

\begin{center}
    \url{https://github.com/lucckkas/patternfinder.git}
\end{center}

El repositorio incluye todo el código fuente, scripts de testing, ejemplos de uso, documentación y archivos de datos de prueba utilizados en este trabajo.

\section{Estructura del Proyecto}

El proyecto sigue la estructura estándar de Go con organización modular:

\begin{verbatim}
Memoria/
|-- cmd/
|   |-- patternfinder/    # Herramienta principal LCS
|   +-- batchcompare/      # Procesamiento por lotes
|-- internal/
|   |-- lcs/              # Implementacion del algoritmo LCS
|   |-- formatter/         # Formateo a notacion PA Line
|   +-- utils/            # Utilidades compartidas
|-- test/                 # Tests unitarios
|-- cifs/                 # Archivos PDB de prueba
|-- texto/                # Documentacion LaTeX
+-- scripts/              # Scripts de testing
    |-- test_batch_modes.sh
    |-- generate_sequences.py
    +-- analyze_results.py
\end{verbatim}

\section{Dependencias y Requisitos}

\subsection{Go (v1.18+)}

El proyecto utiliza módulos de Go. Las dependencias principales son:

\begin{itemize}
    \item \texttt{sync}: Para sincronización de goroutines (WaitGroup, Mutex)
    \item \texttt{fmt}, \texttt{os}, \texttt{strings}: Paquetes estándar
\end{itemize}

\subsection{Python (v3.7+)}

Las herramientas de análisis requieren:

\begin{itemize}
    \item \texttt{Biopython}: Para procesamiento de archivos PDB
    \item \texttt{matplotlib}: Para generación de gráficos
    \item \texttt{numpy}: Para cálculos numéricos
\end{itemize}

Instalación:
\begin{verbatim}
pip install biopython matplotlib numpy
\end{verbatim}

\section{Compilación e Instalación}

\subsection{Compilar herramientas Go}

\begin{verbatim}
# Compilar patternfinder
go build -o build/patternfinder cmd/patternfinder/main.go

# Compilar batchcompare
go build -o build/batchcompare cmd/batchcompare/main.go
\end{verbatim}

\subsection{Ejecutar tests}

\begin{verbatim}
# Tests unitarios
go test ./...

# Benchmark completo
./test_batch_modes.sh
\end{verbatim}


%% Anexo C: Ejemplos de Uso
\appendix{Ejemplos de Uso de las Herramientas}
\label{anexo:ejemplos}

\section{PatternFinder: Búsqueda de Patrones}
\label{anexo:patternfinder}

\subsection{Uso Básico}

\begin{verbatim}
# Modo secuencial
./build/patternfinder seq1.txt seq2.txt

# Modo paralelo (por defecto)
./build/patternfinder seq1.txt seq2.txt -w 4
\end{verbatim}

\subsection{Con Archivos de Ejemplo}

\begin{verbatim}
# Comparar dos secuencias de zinc fingers
echo "ykcglcersfveksalsrhqrvHKN" > seq1.txt
echo "yrcglcersfveksalsrhqrvHRT" > seq2.txt

./build/patternfinder seq1.txt seq2.txt

# Salida:
# Patrones encontrados:
# [YKC]-G-L-C-E-R-S-F-V-E-K-S-A-L-S-R-H-Q-R-V-H
\end{verbatim}

\section{BatchCompare: Procesamiento Masivo}

\subsection{Generar Conjunto de Prueba}

\begin{verbatim}
# Generar 100 secuencias aleatorias de longitud 50
python generate_sequences.py -n 100 -l 50 -o sec.txt
\end{verbatim}

\subsection{Ejecutar Comparaciones}

\begin{verbatim}
# Modo secuencial
./build/batchcompare -f sec.txt -seq -csv results_seq.csv

# Modo paralelo con 12 workers
./build/batchcompare -f sec.txt -w 12 -csv results_par.csv
\end{verbatim}

\subsection{Analizar Resultados}

\begin{verbatim}
# Generar análisis estadístico
python analyze_results.py results_par.csv

# Generar gráficos de rendimiento
python generate_plots2.py results_seq.csv results_par.csv
\end{verbatim}

\section{Interactions.py: Extracción de Patrones desde PDB}

\subsection{Procesar Archivo PDB}

\begin{verbatim}
# Extraer patrones de interacción proteína-ligando
python Interactions.py cifs/1znf.cif

# Salida ejemplo:
# Proteína: 1ZNF
# Ligando: ZN
# Segmento interactuante: HKN
# Patrón: H-K-N
\end{verbatim}
