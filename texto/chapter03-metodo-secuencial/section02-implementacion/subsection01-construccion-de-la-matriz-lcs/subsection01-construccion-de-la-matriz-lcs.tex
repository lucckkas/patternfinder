\subsection{Construcción de la matriz LCS}


La implementación en Go mantiene una única matriz $L$ con las longitudes de la LCS para cada prefijo de las cadenas. No se guarda una segunda tabla de direcciones; durante el retroceso se puede decidir el movimiento (diagonal, arriba o izquierda) simplemente comparando los valores adyacentes de $L$, tal como lo hace el algoritmo clásico \cite{lcs}. El cálculo se realiza fila a fila respetando las dependencias de la programación dinámica; en la versión paralela se procesan las diagonales de la matriz en paralelo para maximizar el uso de los núcleos disponibles.

\begin{verbatim}
Función ConstruirMatrizLCS(secuenciaA, secuenciaB):
    n = len(secuenciaA)
    m = len(secuenciaB)
    L = matriz(n+1, m+1, 0)
    
    Para i desde 1 hasta n:
        Para j desde 1 hasta m:
            Si secuenciaA[i-1] = secuenciaB[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            Sino:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    
    Retornar L
\end{verbatim}

Como se observa, el algoritmo ConstruirMatrizLCS recibe dos secuencias de entrada y construye la matriz $L$, la cual se va llenando según las reglas clásicas del algoritmo LCS;

Recorriendo cada celda de la matriz desde la esquina superior izquierda hasta la inferior derecha:
\begin{itemize}
    \item Si los caracteres actuales de ambas secuencias coinciden, se incrementa en 1 el valor diagonal previo.
    \item Si no coinciden, se toma el máximo entre los valores de la celda superior e izquierda.
\end{itemize}

El algoritmo devuelve únicamente $L$. Cada celda se actualiza en función de la coincidencia o del máximo entre las transiciones vertical y horizontal. Esta información es suficiente para que la fase de retroceso identifique qué movimientos conservan la longitud óptima sin almacenar direcciones explícitas.

