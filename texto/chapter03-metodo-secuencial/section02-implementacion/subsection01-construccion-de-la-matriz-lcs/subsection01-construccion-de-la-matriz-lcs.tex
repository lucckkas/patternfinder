\subsection{Construcción de la matriz LCS}


La implementación en Go mantiene una única matriz $L$ con las longitudes de la LCS para cada prefijo de las cadenas. No se guarda una segunda tabla de direcciones; durante el retroceso se puede decidir el movimiento (diagonal, arriba o izquierda) simplemente comparando los valores adyacentes de $L$, tal como lo hace el algoritmo clásico. El cálculo se realiza fila a fila respetando las dependencias de la programación dinámica; en la versión paralela se procesan las diagonales de la matriz en paralelo para maximizar el uso de los núcleos disponibles.

\begin{algorithm}[H]
    \caption{ConstruirMatrizLCS}
    \begin{algorithmic}[1]
        \Function{ConstruirMatrizLCS}{secuenciaA, secuenciaB}
        \State $n \gets \text{len}(\text{secuenciaA})$
        \State $m \gets \text{len}(\text{secuenciaB})$
        \State $L \gets \text{matriz}(n+1, m+1, 0)$
        \For{$i \gets 1$ \textbf{to} $n$}
        \For{$j \gets 1$ \textbf{to} $m$}
        \If{$\text{secuenciaA}[i-1] = \text{secuenciaB}[j-1]$}
        \State $L[i][j] \gets L[i-1][j-1] + 1$
        \Else
        \State $L[i][j] \gets \max(L[i-1][j], L[i][j-1])$
        \EndIf
        \EndFor
        \EndFor
        \State \Return $L$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

El algoritmo devuelve únicamente $L$, inicializada en la línea 317. Cada celda se actualiza en función de la coincidencia o del máximo entre las transiciones vertical y horizontal. Esta información es suficiente para que la fase de retroceso identifique qué movimientos conservan la longitud óptima sin almacenar direcciones explícitas.

