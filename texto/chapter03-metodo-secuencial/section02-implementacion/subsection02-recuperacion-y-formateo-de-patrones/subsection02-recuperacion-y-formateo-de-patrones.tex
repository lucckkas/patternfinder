\subsection{Recuperación y formateo de patrones}


Con la matriz $L$ disponible se realiza el retroceso para reconstruir las subsecuencias comunes y transformarlas a la notación PA Line \cite{manualpaline}. El código en Go recorre la matriz en sentido inverso utilizando una pila explícita y un registro de caminos visitados que evita explorar el mismo camino con el mismo patrón parcial. El pseudocódigo siguiente condensa ese comportamiento.

\begin{verbatim}
Función RecuperarYFormatearPatrones(L, secuenciaA, secuenciaB):
n = len(secuenciaA)
m = len(secuenciaB)
visitados = diccionario de conjuntos vacío
resultados = conjunto vacío
stack = [(n, m, "", false)]  // (i, j, patrón, hijosProcesados)

Mientras stack no está vacía:
(i, j, patron, listo) = stack.pop()

Si patron está en visitados[(i,j)]:
continuar  // Este camino ya fue explorado

visitados[(i,j)].add(patron)

Si L[i][j] = 0:
resultados.add(patron)
continuar

Si no listo:
stack.push(i, j, patron, true)

Si secuenciaA[i-1] = secuenciaB[j-1]:
nuevo_patron = secuenciaA[i-1] + patron
stack.push(i-1, j-1, nuevo_patron, false)
Sino:
Si L[i-1][j] = L[i][j]:
stack.push(i-1, j, patron, false)

Si L[i][j-1] = L[i][j]:
stack.push(i, j-1, patron, false)

continuar

patrones = conjunto vacío
Para cada s en resultados:
patrones.add(Formatear(s))

    Retornar patrones
    \end{verbatim}\paragraph{Detalle del procedimiento.}
El diccionario `visitados` almacena para cada posición $(i,j)$ el conjunto de patrones parciales con los que se ha llegado. La pila simula la exploración en profundidad, pero ahora cada elemento incluye el patrón construido hasta ese punto. Si las letras coinciden se avanza en diagonal y se concatena la letra al patrón; de lo contrario se exploran las posiciones superiores e izquierdas cuya longitud coincide con $L[i][j]$ manteniendo el mismo patrón parcial. Cuando se llega al origen ($L[i][j] = 0$), el patrón completo se agrega a los resultados finales. La detección de caminos duplicados ocurre verificando si ya se ha visitado la celda $(i,j)$ con el mismo patrón parcial: si es así, se evita reexplorar ese camino ya que conduciría al mismo resultado.

La función \textsc{Formatear} recorre la subsecuencia carácter a carácter, acumula brechas (gaps) contiguas en un contador y los emite como \texttt{x(n)} cuando aparece una coincidencia posterior o al finalizar la cadena. Si no se detecta ningún residuo mayúsculo, devuelve $\varnothing$ para descartar patrones vacíos. Las versiones paralelas del código realizan la exploración de ramas independientes en goroutines (hilos ligeros de ejecución concurrente) \cite{goroutines}, pero el estado compartido sigue siendo la única matriz $L$ junto con el registro de caminos visitados sincronizado mediante mutexes (mecanismo para exclusión mutua en concurrencia).

