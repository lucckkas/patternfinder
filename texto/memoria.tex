%% inicio, la clase del documento es iccmemoria.cls
\documentclass{iccmemoria}
\usepackage{xcolor}
\newcommand{\renzo}[1]{{\color{red}{#1}}}

%% datos generales y para la tapa
\titulo{Desarrollo de un algoritmo paralelo para la búsqueda de patrones proteína-ligando}
\author{Luckas Strnad}
\supervisor{Renzo Angles}


\director{Profesor del ramo Memoria de Título} % Arias
\date{diciembre, 2025}

%% inicio de documento
\begin{document}

%% crea la tapa
\maketitle

%% dedicatoria
\begin{dedicatory}
Dedicado a ...
\end{dedicatory}

%% agradecimientos
\begin{acknowledgment}
Agradecimientos a ...
\end{acknowledgment}

%% indices
\tableofcontents
\listoffigures
\listoftables

%% resumen
\begin{resumen}
La tarea de identificar patrones en proteínas es un desafío clave en bioinformática, esencial para entender la interacción de aminoácidos con otras moléculas, como los ligandos. Los métodos tradicionales enfrentan serias limitaciones debido al crecimiento combinatorio de las comparaciones necesarias, lo que implica un uso intensivo de recursos computacionales y prolongados tiempos de procesamiento. 

Para abordar esta problemática, se propuso y desarrolló un algoritmo paralelo que mejora la eficiencia de la búsqueda. Esta solución permite identificar los segmentos de aminoácidos que interactúan con ligandos y optimiza la generación y comparación de subsecuencias mediante la distribución de tareas entre múltiples hilos de procesamiento. La implementación, que hace uso de la librería Biopython y un enfoque en el lenguaje de programacion Golang, muestra un claro avance en cuanto a la reducción del tiempo de procesamiento respecto al método secuencial.

Sin embargo, aunque el algoritmo paralelo presenta mejoras notables en rendimiento, la eficiencia puede variar dependiendo de la longitud de las secuencias y el hardware empleado. Además, la solución podría beneficiarse de futuras optimizaciones para adaptarse a técnicas más avanzadas de manejo de datos extensos, además de refinamiento de los patrones mediante conocimientos en bioinformática.

La proyección de este trabajo es prometedora, con aplicaciones potenciales en el diseño de fármacos y la ingeniería de proteínas, donde se requiere un análisis rápido y preciso de patrones proteína-ligando. También se considera la integración del algoritmo con otras herramientas bioinformáticas para realizar análisis más complejos y en tiempo real, extendiendo su aplicabilidad a estudios de mayor envergadura.
\end{resumen}

%% abstract

%% contenido del primer capítulo
\chapter{Introducción}

La tarea de descubrir patrones en proteínas es fundamental en bioinformática y biología computacional. Los algoritmos que permiten identificar secuencias de aminoácidos relevantes son esenciales para comprender la estructura y función de las proteínas, así como sus interacciones con otras moléculas, como los ligandos. Sin embargo, estos algoritmos suelen enfrentar desafíos significativos en términos de eficiencia y tiempo de procesamiento.

\section{Contexto}
Tradicionalmente, estos algoritmos adoptan un enfoque exhaustivo, generando y comparando todas las posibles subsecuencias de aminoácidos. Aunque este método garantiza una cobertura completa, enfrenta un problema crítico: la cantidad de comparaciones aumenta de forma combinatoria con el tamaño de la secuencia. Esta explosión combinatoria conlleva un uso intensivo de recursos computacionales y tiempos de procesamiento prolongados.

\section{Motivación y problemática}
La principal limitación de los métodos actuales radica en el enorme número de comparaciones generadas debido al crecimiento combinatorio de las posibles subsecuencias. Este problema afecta significativamente la eficiencia del algoritmo y puede hacer inviable su aplicación en estudios complejos o en tiempo real. Abordar esta problemática es fundamental para optimizar la búsqueda de patrones en proteínas y mejorar el rendimiento computacional, permitiendo análisis más rápidos y eficientes sin comprometer la calidad de los resultados.

\section{Objetivos}
\paragraph{Objetivo general}
\begin{itemize}
    \item Desarrollar una versión paralelizada de un algoritmo para el descubrimiento de patrones estructurales en proteínas
\end{itemize}
\paragraph{Objetivos específicos} 
\begin{itemize}
    \item Identificar las partes del algoritmo que pueden ser paralelizadas.
    \item Diseñar un algoritmo que haga uso de hilos para descubrir patrones usando computación paralela.
    \item Implementar el algoritmo basado en hilos.
    \item Evaluar el rendimiento del algoritmo en paralelo frente a la versión secuencial.
\end{itemize}

\section{Metodología}

El desarrollo del proyecto seguirá un enfoque estructurado que combina el método científico y la evaluación cuantitativa para garantizar un proceso riguroso y basado en evidencia. A continuación, se describen las etapas de cada metodología aplicada en el proyecto.

\subsection{Etapas del Método Científico}
El proyecto se desarrollará siguiendo las etapas clásicas del método científico, asegurando un enfoque sistemático y objetivo:

\paragraph{Observación} Se inicia con la revisión y análisis del algoritmo secuencial existente, identificando el problema central: la explosión combinatoria que limita su eficiencia. Esta etapa implica recopilar datos y entender a fondo el comportamiento actual del algoritmo.

\paragraph{Formulación de hipótesis} Basándose en la observación, se planteará la hipótesis de que la paralelización mediante hilos mejorará significativamente el tiempo de ejecución del algoritmo sin comprometer la calidad de los resultados.

\paragraph{Experimentación} Se implementará la versión paralelizada del algoritmo y se llevarán a cabo experimentos para poner a prueba la hipótesis. Esta etapa incluirá la ejecución del algoritmo bajo diferentes configuraciones, variando el número de hilos y analizando cómo se distribuye la carga de trabajo.

\paragraph{Análisis de resultados} Los datos obtenidos durante la experimentación se analizarán para verificar si la paralelización cumple con las expectativas de mejora de rendimiento. Se compararán los tiempos de ejecución y el uso de recursos entre la versión secuencial y la paralela.

\paragraph{Conclusiones} Basándose en el análisis de los resultados, se extraerán conclusiones sobre la efectividad de la paralelización. Si los resultados son positivos, se documentará el éxito del enfoque; en caso contrario, se propondrán nuevas iteraciones o ajustes.

\subsection{Etapas de la Evaluación Cuantitativa}
La evaluación cuantitativa complementa el uso del método científico mediante la recolección y análisis de datos numéricos para medir y validar los resultados:

\paragraph{Definición de métricas} Se identificarán las métricas clave, como el tiempo de ejecución y el uso de recursos.

\paragraph{Recolección de datos} Durante la etapa de experimentación, se registrarán los tiempos de ejecución y el uso de recursos del sistema en múltiples escenarios de prueba.

\paragraph{Análisis estadístico} Los datos recolectados serán analizados estadísticamente para identificar patrones, diferencias significativas entre la versión secuencial y paralelizada, y la eficiencia de la paralelización. Este análisis permitirá validar si la paralelización logra mejorar el rendimiento del algoritmo conforme a los objetivos del proyecto.

\paragraph{Interpretación y presentación} Los resultados del análisis cuantitativo se interpretarán y se incluirán en la documentación final del proyecto, mostrando de forma clara el impacto de la paralelización en el rendimiento del algoritmo.

Este enfoque metodológico, que combina el Método Científico con una evaluación cuantitativa detallada, asegura que el proyecto se desarrolle de manera sistemática y objetiva, permitiendo validar de forma rigurosa las mejoras obtenidas y la consecución de los objetivos propuestos.

\section{Plan de Trabajo}

El plan de trabajo del proyecto se estructura en varias etapas que cubren desde el análisis preliminar hasta la documentación y evaluación final. Cada etapa está diseñada para asegurar un desarrollo metódico, con actividades claramente definidas y recursos adecuados para alcanzar los objetivos planteados.

\subsection{Etapa 1: Análisis y Estudio Inicial}
En esta primera etapa, se realizará un análisis exhaustivo del algoritmo secuencial. El objetivo es entender en profundidad su funcionamiento y detectar las partes críticas que pueden ser paralelizadas para mejorar su eficiencia.

\subsection{Etapa 2: Diseño del Algoritmo Paralelo}
El diseño del algoritmo paralelo se basará en los resultados obtenidos en la etapa anterior. En esta fase, se planificará cómo distribuir las tareas entre múltiples hilos de forma eficiente, asegurando un balance óptimo de carga. La estrategia de paralelización será desarrollada considerando las mejores prácticas en el uso de hilos en Golang. Se utilizarán referencias de documentación técnica y ejemplos previos de paralelización como base para estructurar un diseño que permita mejorar el rendimiento sin comprometer la precisión de los resultados.

\subsection{Etapa 3: Implementación y Desarrollo}
La implementación del algoritmo paralelo es una de las etapas más críticas del proyecto. Se llevará a cabo en Golang, aprovechando la capacidad de procesamiento multi-hilo de las herramientas de desarrollo disponibles. Durante esta fase, se trabajará en asegurar la correcta gestión de la concurrencia y en optimizar el código para maximizar la eficiencia de los hilos. Se utilizará un control de versiones como Git para mantener un seguimiento riguroso del progreso y garantizar la integridad del desarrollo.

\subsection{Etapa 4: Pruebas y Validación}
La etapa de pruebas y validación es esencial para comprobar la efectividad del algoritmo paralelo. Se realizarán pruebas para intentar asegurar la integridad y coherencia de los datos generados. Además, se comparará el rendimiento de la versión paralela con la versión secuencial para cuantificar las mejoras en tiempo de ejecución. Los datos de prueba se obtendrán de bases de datos de proteínas de acceso público, y se utilizarán herramientas de monitoreo de rendimiento para un análisis detallado.

\subsection{Etapa 5: Documentación de la Memoria}
La documentación del proyecto se realizará de manera meticulosa, incluyendo todos los aspectos del desarrollo, desde los antecedentes y la metodología empleada hasta los resultados obtenidos y las conclusiones. Esta etapa implicará el uso de herramientas de procesamiento de texto como LaTeX para asegurar una presentación profesional y ordenada del contenido. La memoria será un reflejo integral del trabajo realizado, proporcionando una base sólida para su evaluación académica.

\section{Resultados Esperados}
\paragraph{Objetivos específicos}

\subparagraph{Objetivo Específico 1: Identificar las partes del algoritmo que pueden ser paralelizadas.}
\begin{itemize}
    \item \textbf{Resultado Esperado:} Se espera identificar de manera clara las secciones del algoritmo secuencial que presentan alta carga computacional y que pueden beneficiarse de la paralelización.
    \item \textbf{Pruebas para Lograr Resultado Esperado:} Identificación de cuellos de botella a través de pruebas de rendimiento.
\end{itemize}

\subparagraph{Objetivo Específico 2: Diseñar un algoritmo que haga uso de hilos para descubrir patrones usando computación paralela.}
\begin{itemize}
    \item \textbf{Resultado Esperado:} Se espera tener un diseño detallado y optimizado del algoritmo que divida el trabajo en tareas paralelas de forma efectiva, manteniendo la precisión del análisis.
    \item \textbf{Pruebas para Lograr Resultado Esperado:} Validación del diseño mediante revisiones por pares y simulaciones de ejecución en entornos controlados para evaluar la distribución de carga y sincronización de los hilos.
\end{itemize}

\subparagraph{Objetivo Específico 3: Implementar el algoritmo basado en hilos.}
\begin{itemize}
    \item \textbf{Resultado Esperado:} Se espera que el algoritmo sea implementado con éxito y que ejecute de forma paralela los procesos de comparación de subsecuencias sin errores de concurrencia.
    \item \textbf{Pruebas para Lograr Resultado Esperado:} Ejecuciones de prueba del código en entornos de desarrollo, uso de pruebas unitarias para validar la funcionalidad de cada parte del código, y monitoreo del uso de CPU y memoria durante la ejecución.
\end{itemize}

\subparagraph{Objetivo Específico 4: Evaluar el rendimiento del algoritmo en paralelo frente a la versión en serie.}
\begin{itemize}
    \item \textbf{Resultado Esperado:} Se espera que el algoritmo en paralelo reduzca significativamente el tiempo de procesamiento en al menos un 50\% respecto a la versión en serie, sin comprometer la precisión de los resultados.
    \item \textbf{Pruebas para Lograr Resultado Esperado:} Comparación de tiempos de ejecución entre la versión paralela y la versión secuencial del algoritmo en diferentes conjuntos de datos de prueba, y análisis de la eficiencia de los hilos en función del número de hilos usados.
\end{itemize}


\section{Solución}

\section{Contribuciones}


%% contenido del segundo capítulo
\chapter{Contexto}

\section{Proteínas, ligandos y cadenas}
Las definiciones formales de algunos conceptos importantes son:
\begin{itemize}
    \item Aminoácidos: Son moléculas que se combinan para formar proteínas.\cite{defLigando}
    \item Proteínas: Son moléculas grandes y complejas que desempeñan muchas funciones críticas en el cuerpo. Realizan la mayor parte del trabajo en las células y son necesarias para la estructura, función y regulación de los tejidos y órganos del cuerpo.\cite{defProteina}
    \item Ligandos: Es una sustancia (usualmente una molécula pequeña) que forma un complejo con una biomolécula. En un sentido más estricto, es una molécula que envía una señal al unirse al centro activo de una proteína. \cite{3} Es decir, un ligando es una molécula que se une a una proteína, alterando su estructura y función.
\end{itemize}

Hay 20 tipos diferentes de aminoácidos que se pueden combinar para formar una proteína. La secuencia de aminoácidos determina la estructura tridimensional única de cada proteína y su función específica \cite{defProteina}.

El Cuadro \ref{tab:aminos} contiene la lista de aminoácidos estándar.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Nombre} & \textbf{Abreviatura} & \textbf{Símbolo} \\
\hline
Alanina & Ala & A \\
Arginina & Arg & R \\
Asparagina & Asn & N \\
Aspártico & Asp & D \\
Cisteína & Cys & C \\
Fenilalanina & Phe & F \\
Glicina & Gly & G \\
Glutámico & Glu & E \\
Glutamina & Gln & Q \\
Histidina & His & H \\
Isoleucina & Ile & I \\
Leucina & Leu & L \\
Lisina & Lys & K \\
Metionina & Met & M \\
Prolina & Pro & P \\
Serina & Ser & S \\
Tirosina & Tyr & Y \\
Treonina & Thr & T \\
Triptófano & Trp & W \\
Valina & Val & V \\
\hline
\end{tabular}
\caption{Lista de aminoácidos estándar.}
\label{tab:aminos}
\end{table}

Un ejemplo de una secuencia de proteína, correspondiente a la proteína 5PNQ \cite{prote5PNQ}, es el siguiente:

\begin{verbatim}
MHHHHHHSSGVDLGTENLYFQSMETMKSKANCAQNPNCNIMIFHPTKEEFNDFDKYIAYMESQG
AHRAGLAKIIPPKEWKARETYDNISEILIATPLQQVASGRAGVFTQYHKKKKAMTVGEYRHLAN
SKKYQTPPHQNFEDLERKYWKNRIYNSPIYGADISGSLFDENTKQWNLGHLGTIQDLLEKECGV
VIEGVNTPYLYFGMWKTTFAWHTEDMDLYSINYLHLGEPKTWYVVPPEHGQRLERLARELFPGS
SRGCGAFLRHKVALISPTVLKENGIPFNRITQEAGEFMVTFPYGYHAGFNHGFNCAEAINFATP
RWIDYGKMASQCSCGEARVTFSMDAFVRILQPERYDLWKRGQDR
\end{verbatim}

Adicionalmente y para facilitar el entendimiento estableceremos el siguiente vocabulario para referirnos a cada parte de la proteína que se obtiene durante el algoritmo:
\begin{itemize}
    \item Secuencia: Para referirnos a una proteína completa.
    \item Segmento: Parte de la proteína que interactúa con un ligando y recortamos.
    \item Subsecuencia: Fragmento de la proteína generado por el algoritmo para buscar los patrones.
\end{itemize}

\section{Patrones Proteína-Ligando}

Un patrón proteína-ligando es una secuencia específica de aminoácidos alrededor de un ligando que se repite en múltiples proteínas. Estos patrones representan regiones funcionales donde ocurre la interacción entre la proteína y la molécula del ligando, lo cual es esencial para la actividad biológica de la proteína. La identificación y análisis de estos patrones permiten comprender mejor cómo las proteínas llevan a cabo sus funciones.

La detección de estos patrones es fundamental en diversas áreas, como el diseño de fármacos, donde se busca identificar moléculas que puedan unirse eficazmente a una proteína objetivo para modificar su actividad. También es crucial en la ingeniería de proteínas, donde modificar o diseñar nuevas proteínas con funciones específicas requiere un entendimiento detallado de los patrones de interacción proteína-ligando.

Para representar estos patrones en secuencias proteicas, se utilizan herramientas y notaciones especializadas como la PA Line de PROSITE\cite{manualpaline}, que permite describir patrones complejos de manera concisa y estandarizada. Esta notación facilita la comparación y el análisis de secuencias, permitiendo a los investigadores identificar rápidamente regiones de interés y predecir posibles interacciones funcionales.

\section{Notación PA Line de Prosite}
Para representar patrones en secuencias proteicas, se utiliza la notación PA Line de PROSITE\cite{manualpaline}, una herramienta ampliamente reconocida en bioinformática.

La notación PA Line es un formato estandarizado que permite describir de manera concisa y precisa los patrones de secuencias. Esta notación utiliza símbolos y reglas específicas para representar aminoácidos individuales, opciones alternativas en una posición dada, repeticiones y rangos de longitud. A continuación, se describen algunos elementos clave de esta notación:\cite{manualpaline}: 
\begin{itemize}
    \item \textbf{Código IUPAC}: Se utilizan los códigos de una letra estándar para los aminoácidos.
    \item \textbf{Posición indefinida}: Se usa el símbolo \texttt{x} para representar cualquier aminoácido en una posición dada.
    \item \textbf{Ambigüedades}: Se indican mediante corchetes \texttt{[]} enumerando los aminoácidos permitidos en una posición. Ejemplo: \texttt{[ALT]} significa Ala, Leu o Thr. $($por las letras A, L y T$)$
    \item \textbf{Exclusión de aminoácidos}: Se indica mediante llaves \texttt{\{\}} enumerando los aminoácidos no permitidos en una posición. Ejemplo: \texttt{\{AM\}} significa cualquier aminoácido excepto Ala o Met.
    \item \textbf{Repetición}: Se denota usando un número o un rango entre paréntesis. Ejemplo: \texttt{x(3)} representa tres posiciones consecutivas ocupadas por cualquier aminoácido, y \texttt{x(2,4)} indica de dos a cuatro posiciones consecutivas de cualquier aminoácido.
    \item \textbf{Restricciones en los extremos}: Se utiliza el símbolo \texttt{<} para restringir un patrón al extremo N-terminal y \texttt{>} para el extremo C-terminal de una secuencia.
    \item \textbf{Patrón finalizado}: Un patrón siempre termina con un punto (\texttt{.}).
    \item \textbf{Ejemplo de patrón}: \texttt{PA [AC]-x-V-x(4)-\{ED\}.} se traduce como: Ala o Cys, seguido de cualquier aminoácido, seguido de Val, seguido de cualquier cuatro aminoácidos, seguido de cualquier aminoácido excepto Glu o Asp.
\end{itemize}

\section{Métodos para descubrir patrones}

La búsqueda de patrones en secuencias proteicas es una tarea crucial en bioinformática, ya que permite identificar regiones conservadas que pueden ser funcionalmente relevantes, como sitios de unión a ligandos. A continuación, se describen algunos métodos y herramientas clave, incluyendo Pratt y su versión web, y se discute su utilidad para la identificación de patrones proteína-ligando.

\subsection{Pratt}

Pratt  es una herramienta ampliamente utilizada para la identificación de patrones conservados en conjuntos de secuencias proteicas. Mediante la búsqueda de patrones comunes en un conjunto de secuencias.

Pratt utiliza algoritmos que consideran la variabilidad en las secuencias, permitiendo identificar patrones que no necesariamente están perfectamente conservados, pero que presentan similitudes significativas. Esto es especialmente útil en el análisis de familias de proteínas donde la conservación es parcial debido a divergencias evolutivas.

Algunas características clave de Pratt incluyen:

\begin{itemize} 
    \item \textbf{Flexibilidad en la definición de patrones}: Permite especificar parámetros como la longitud mínima y máxima de los patrones, el número mínimo de secuencias que deben contener el patrón, y la posibilidad de incluir posiciones variables o ambiguas. 
    \item \textbf{Incorporación de gaps}: Puede manejar espacios en los patrones, lo que es útil cuando los motivos funcionales están separados por regiones variables. 
     
    \item \textbf{Salida en formato PROSITE}: Los patrones se presentan en la notación PA Line de PROSITE, facilitando su interpretación y uso en otras herramientas bioinformáticas. \end{itemize}

\subsection{Versión Web de Pratt}

La versión web de PRATT está disponible a través del servidor ExPASy, que es parte del Swiss Institute of Bioinformatics. Esta interfaz web permite a los usuarios ejecutar Pratt sin necesidad de instalar software localmente, facilitando su acceso y uso.

Además, el Protein Data Bank (PDB) ofrece recursos para el análisis de estructuras proteicas, y aunque no proporciona directamente una versión web de Pratt, las secuencias y estructuras disponibles en el PDB pueden ser utilizadas como entrada para Pratt. Los usuarios pueden extraer secuencias de proteínas del PDB y utilizarlas en Pratt para identificar patrones conservados.

Si bien Pratt es una herramienta potente para identificar patrones conservados en secuencias proteicas, no está específicamente diseñada para identificar patrones de interacción proteína-ligando. Los patrones descubiertos por Pratt corresponden a secuencias de aminoácidos que están conservadas entre diferentes proteínas, lo que puede incluir sitios de unión a ligandos si estos sitios están conservados.

La identificación de patrones proteína-ligando requiere información sobre las interacciones específicas entre los aminoácidos de la proteína y el ligando. Esto generalmente implica el análisis de datos estructurales 3D, como los disponibles en el PDB, y el uso de herramientas especializadas que consideran la geometría y las propiedades químicas de la interacción.

\subsection{Método base para descubrir patrones}\label{algoritmooriginal}

Este trabajo está basado en un trabajo anterior \cite{francisco}, el autor anterior propuso un algoritmo secuencial para descubrir un patrón. Este algoritmo busca patrones entre 2 secuencias de aminoácidos, por ejemplo para las secuencias ABCD y AHCD encontraría el patrón A-X(1)-CD. Nótese que el algoritmo no tiene en cuenta las interacciones con los ligandos.

Ahora pasemos a analizar cómo funciona detalladamente el algoritmo para una cadena de aminoácidos de largo \textit{n} y otra de largo \textit{m}:

\textbf{Paso 1: }
Por cada numero desde 0 hasta  $2^n - 1$  se obtiene la representación binaria de cada numero, usando \textit{n} dígitos. Y repetimos de igual manera para \textit{m} en lugar de \textit{n}

\textbf{Paso 2: }
Generar las subsecuencias, para esto se realizan copias de cada cadena de aminoácidos original por cada numero generado previamente siguiendo el siguiente patrón: si el dígito es un 0 se coloca un carácter X, si el digito es un 1 colocar el carácter correspondiente a la posición en la cadena de aminoácidos original.

\textbf{Paso 3: }
Recorrer las subsecuencias generadas y reemplazar las X por números correspondientes a cuantas X consecutivas hayan.

\textbf{Paso 4: }
Eliminar todos los numeros que comienzan o finalizan una subsecuencia.

\textbf{Paso 5: }
Comparar las subsecuencias, para esto se compara cada subsecuencia de la cadena de largo \textit{n} con cada subsecuencia de la cadena de largo \textit{m}. Si hay 2 subsecuencias con los mismos caracteres se tiene una coincidencia exacta y se guarda como patron candidato, si coinciden las letras pero no los números se genera un patrón usando la notación Prosite PA Line \cite{manualprosite}.

\textbf{Paso 6: }
Puntuar las subsecuencias para encontrar el patrón optimo. Esta puntuación consiste en sumar la cantidad de aminoácidos multiplicados por el largo de la secuencia de entrada mas extensa, los X(\textit{h}) o X(\textit{i},\textit{j}) suman \textit{h} o \textit{j}, respectivamente, (considerando que \textit{j} $>$ \textit{i})

\textbf{Ejemplo}

Considerando las cadenas \textit{ABC} y \textit{BC} como entrada el algoritmo hace lo siguiente:

\textbf{Paso 1}

Para la cadena \textit{ABC}: 000, 001, 010, 011, 100, 101, 110, 111
Para la cadena \textit{AB}:  00, 01, 10, 11

\textbf{Paso 2}

Para la cadena \textit{ABC}: XXX, XXC, XBX, XBC, AXX, AXC, ABX, ABC
Para la cadena \textit{AB}:  XX, XB, AX, AB

\textbf{Paso 3}

Para la cadena \textit{ABC}: 3, 2C, 1B1, 1BC, A2, A1C, AB1, ABC
Para la cadena \textit{AB}: 2, 1B, A1, AB

\textbf{Paso 4}

(los - marcan cadenas que al ser solo números se eliminan)
Para la cadena \textit{ABC}: -, C, B, BC, A, A1C, AB, ABC
Para la cadena \textit{AB}: -, B, A, AB

\textbf{Paso 5}
Aquí abría que comparar las subsecucias de la primera cadena con cada subcadena de la segunda dando un total de 21 comparaciones (7 subsecuencias de la cadena \textit{ABC} y 3 de la cadena \textit{AB})

Para simplificar diremos que al comparar encontramos las siguientes coincidencias: B, A y AB

\textbf{Paso 6}

Al puntuar solo tenemos que contar la cantidad de aminoácidos de la subsecuencia y multiplicarlo por el largo de la cadena original mas larga (3,  correspondiente a la cadena \textit{ABC})

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Subsecuencia} & \textbf{Puntuación} \\
\hline
AB & 6 \\
A  & 3 \\
B  & 3 \\
\hline
\end{tabular}
\caption{Puntuaciones de subsecuencias.}
\end{table}

\vspace{1em}

El algoritmo original crea una gran cantidad de subcadenas que deben compararse entre sí, lo que da lugar a una gran cantidad de comparaciones debido a la naturaleza combinatoria del algoritmo. Esta característica limita significativamente el rendimiento y escalabilidad del algoritmo en su forma secuencial, lo que limita su aplicación eficiente en conjuntos de datos proteicos reales. La solución a este problema permitirá acelerar el proceso de comparación y mejorar el rendimiento del algoritmo para el análisis de patrones estructurales en proteínas.

Como podemos ver este método no esta tomando en cuenta cuales aminoácidos interactúan con un ligando, por lo que uno de los primero cambios que se realizaron es tener en cuenta esto.

%% contenido del tercer capítulo
\chapter{Método secuencial}
%% poner intro
\section{Extracción de datos}

Se desarrolló un algoritmo que permite detectar los aminoácidos que interactúan con los ligandos en una proteína y que retorna los segmentos de la proteína que contienen esos aminoácidos.

Para esto se utilizó la librería \texttt{Biopython} \cite{biopython_articulo}, la cual es una colección de Python disponible gratuitamente módulos para biología molecular computacional, y el paquete Bio.PDB \cite{biopdb} que facilita el uso y procesamiento de los archivos \texttt{.pdb}, que corresponden a archivos del Protein Data Bank (PDB) \cite{pdb}.

\subsection{Descripción del Algoritmo}

El algoritmo se compone de varios pasos que se detallan a continuación, junto con ejemplos aplicados a la proteína \texttt{1znf} para facilitar su comprensión.

\subsubsection{Configuración Inicial}

En esta sección, se establecen los parámetros iniciales y se preparan las estructuras de datos necesarias para el análisis.

\begin{algorithm}[H]
\caption{Proceso de análisis de interacción proteína-ligando}
\begin{algorithmic}[1]
\State Establecer el umbral de distancia para considerar una interacción (\texttt{distance\_threshold})
\State Leer el archivo PDB para obtener la estructura de la proteína
\State Inicializar listas para residuos de ligando (\texttt{ligand\_residues}), átomos de proteína (\texttt{protein\_atoms}) y lista de residuos (\texttt{residues\_list})
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo:}

Para la proteína \texttt{1znf}, se establece un umbral de distancia de 4.0 \AA. Se lee el archivo \texttt{1znf.pdb} y se inicializan las listas vacías para almacenar los residuos de ligando, átomos de proteína y lista de residuos.

\subsubsection{Recopilación de Información de la Estructura}

Se recorre la secuencia para identificar los ligandos y aminoácidos de la proteína, almacenando la información relevante en listas para su posterior procesamiento.

\begin{algorithm}[H]
\caption{Proceso de extracción de ligandos y átomos de proteína}
\begin{algorithmic}[1]
\ForAll{cadena en la estructura}
    \ForAll{residuo en la cadena}
        \State Obtener \texttt{hetfield}, \texttt{resseq} y \texttt{icode} para identificar el residuo
        // hetfield: Indica el tipo de residuo. 
        
        // resseq: Es el número de secuencia del residuo
        
        // icode: Código de inserción.
        
        \State Obtener el nombre del residuo (\texttt{resname})
        \If{el residuo es un ligando}
            \State Añadir el residuo a \texttt{ligand\_residues}
        \ElsIf{el residuo es de proteína}
            \State Añadir los átomos del residuo a \texttt{protein\_atoms}
            \State Añadir el residuo a \texttt{residues\_list}
        \EndIf
    \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo:}

Al procesar la proteína \texttt{1znf}, se identifican los ligandos y de aminoácidos. Los ligandos encontrados son \texttt{NH2}, \texttt{ACE} y \texttt{ZN}, mientras que lo demás corresponde a los aminoácidos de la cadena.

\subsubsection{Detección y Procesamiento de Ligandos}

Se verifica si existen ligandos en la estructura y se procesa cada uno de ellos individualmente.

\begin{algorithm}[H]
\caption{Identificación de aminoácidos interactuantes con ligandos}
\begin{algorithmic}[1]
\If{no se encontraron residuos de ligando}
    \State Terminar el algoritmo
\EndIf
\State Obtener códigos únicos de ligandos (\texttt{ligand\_codes})
\ForAll{código de ligando \texttt{lig\_code} en \texttt{ligand\_codes}}
    \State Obtener los átomos del ligando actual
    \State Proceder con la identificación de aminoácidos interactuantes
\EndFor
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo:}

En la proteína \texttt{1znf}, se encontraron los ligandos \texttt{NH2}, \texttt{ACE} y \texttt{ZN}. El algoritmo procesará cada uno de estos ligandos de forma individual.

\subsubsection{Identificación de Aminoácidos Interactuantes}

Utilizando un algoritmo de búsqueda de vecinos (NeighborSearch), se identifican los aminoácidos de la proteína que interactúan con el ligando, basándose en el umbral de distancia definido. Esto consiste en comparar la distancia de cada átomo del ligando con los átomos de la proteína y determinar si algún átomo del aminoácido está a una distancia menor al umbral. Un residuo se considera interactuante si al menos uno de sus átomos está dentro del umbral de distancia respecto a cualquier átomo del ligando.

\begin{algorithm}[H]
\caption{Búsqueda de residuos interactuantes con ligandos}
\begin{algorithmic}[1]
\State Crear una búsqueda de vecinos (\texttt{NeighborSearch}) con los átomos de proteína
\State Inicializar un conjunto de residuos que interactúan (\texttt{interacting\_residues})
\ForAll{átomo en los átomos del ligando}
    \State Buscar residuos vecinos dentro del umbral de distancia
    \State Añadir estos residuos a \texttt{interacting\_residues}
\EndFor
\end{algorithmic}
\end{algorithm}

\paragraph{Ejemplo: Identificación de Aminoácidos Interactuantes}

Al procesar el ligando \texttt{NH2} de la proteína \texttt{1znf}, el algoritmo identifica los aminoácidos que se encuentran dentro de 4.0 \AA\ de cualquier átomo del ligando. Los aminoácidos identificados corresponden a los aminoácidos \texttt{H}, \texttt{K} y \texttt{N} al final de la secuencia.

\subsubsection{Generación de la Secuencia Modificada}

Se genera la secuencia completa de aminoácidos de la proteína, utilizando letras mayúsculas para los aminoácidos que interactúan con el ligando y minúsculas para los que no.

\begin{algorithm}[H]
\caption{Generación de secuencia resaltada de residuos}
\begin{algorithmic}[1]
\State Inicializar la secuencia resaltada (\texttt{highlighted\_sequence})
\ForAll{residuo en \texttt{residues\_list}}
    \State Obtener el nombre del residuo (\texttt{resname})
    \State Convertir \texttt{resname} a código de una letra (\texttt{one\_letter})
    \If{el residuo está en \texttt{interacting\_residues}}
        \State Convertir \texttt{one\_letter} a mayúscula
    \Else
        \State Convertir \texttt{one\_letter} a minúscula
    \EndIf
    \State Añadir \texttt{one\_letter} a \texttt{highlighted\_sequence}
\EndFor
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo: Generación de la Secuencia Modificada}

Con la secuencia original de la proteína \texttt{1znf}:

\begin{center}
\texttt{ykcglcersfveksalsrhqrvhkn}
\end{center}

Y considerando que los residuos que interactúan con el ligando \texttt{NH2} son \texttt{H}, \texttt{K} y \texttt{N}, la secuencia modificada será:

\begin{center}
\texttt{ykcglcersfveksalsrhqrvHKN}
\end{center}

Las letras mayúsculas indican los aminoácidos que interactúan con el ligando.

\subsubsection{Extracción y Presentación del Segmento Interactuante}

Se extrae el segmento de la secuencia que abarca desde el primer hasta el último aminoácido que interactúa con el ligando.

\begin{algorithm}[H]
\caption{Detección de segmento interactuante en la secuencia resaltada}
\begin{algorithmic}[1]
\State Utilizar una expresión regular para encontrar el segmento que inicia y termina con una letra mayúscula
\If{se encuentra una coincidencia}
    \State Extraer el segmento interactuante (\texttt{interacting\_segment})
    \State Mostrar el segmento interactuante al usuario
\Else
    \State Indicar que no se encontraron residuos que interactúen con el ligando
\EndIf
\end{algorithmic}
\end{algorithm}
 ligando y se muestra al usuario.

\begin{algorithm}[H]
\caption{Detección de segmento interactuante en la secuencia resaltada}
\begin{algorithmic}[1]
\State Utilizar una expresión regular para encontrar el segmento que inicia y termina con una letra mayúscula
\If{se encuentra una coincidencia}
    \State Extraer el segmento interactuante (\texttt{interacting\_segment})
    \State Mostrar el segmento interactuante al usuario
\Else
    \State Indicar que no se encontraron residuos que interactúen con el ligando
\EndIf
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo: Extracción y Presentación del Segmento Interactuante}

Aplicando la expresión regular a la secuencia modificada:

\begin{center}
\texttt{ykcglcersfveksalsrhqrvHKN}
\end{center}

Se extrae el segmento que va desde la primera letra mayúscula hasta la última:

\begin{center}
\texttt{HKN}
\end{center}

Este es el segmento de aminoácidos que interactúa con el ligando \texttt{NH2}.
El mismo proceso se repite para los otros ligandos identificados.

\subsection{Generación de Subsecuencias}

Para cada segmento, el algoritmo genera todas las posibles subsecuencias reemplazando o no cada carácter por una marca especial, denotada como \texttt{``x''}. Este proceso implica la creación de todas las combinaciones binarias posibles donde cada posición puede mantener el carácter original o ser reemplazada por \texttt{``x''}. Si el segmento tiene una longitud $n$, se generan $2^n$ subsecuencias.

Después de generar las subsecuencias, el algoritmo elimina las \texttt{``x''} al inicio y al final de cada subsecuencia. Es decir, las \texttt{``x''} que están al principio o al final de la subsecuencia son removidas.

Por ejemplo, para el segmento \texttt{AbC}, las subsecuencias generadas son:

\begin{itemize}
    \item \texttt{AbC} (sin cambios)
    \item \texttt{xbC} $\rightarrow$ \texttt{bC}
    \item \texttt{AxC} (sin cambios)
    \item \texttt{Abx} $\rightarrow$ \texttt{Ab}
    \item \texttt{xxC} $\rightarrow$ \texttt{C}
    \item \texttt{xbx} $\rightarrow$ \texttt{b}
    \item \texttt{Axx} $\rightarrow$ \texttt{A}
    \item \texttt{xxx} $\rightarrow$ (vacío)
\end{itemize}

De manera similar, para el segmento \texttt{AgC}, las subsecuencias generadas son:

\begin{itemize}
    \item \texttt{AgC} (sin cambios)
    \item \texttt{xgC} $\rightarrow$ \texttt{gC}
    \item \texttt{AxC} (sin cambios)
    \item \texttt{Agx} $\rightarrow$ \texttt{Ag}
    \item \texttt{xxC} $\rightarrow$ \texttt{C}
    \item \texttt{xgx} $\rightarrow$ \texttt{g}
    \item \texttt{Axx} $\rightarrow$ \texttt{A}
    \item \texttt{xxx} $\rightarrow$ (vacío)
\end{itemize}

Nota: Las subsecuencias resultantes después de eliminar las \texttt{``x''} iniciales y finales pueden ser vacías; estas subsecuencias vacías son descartadas.

\subsection{Compresión de \texttt{``x''} consecutivas}

En las subsecuencias resultantes, las \texttt{``x''} consecutivas se comprimen y se representan como \texttt{x(n)}, donde $n$ es el número de \texttt{``x''} consecutivas.

Aplicando esto a nuestras subsecuencias, obtenemos:

Para el segmento \texttt{AbC}:

\begin{itemize}
    \item \texttt{AbC} (sin cambios)
    \item \texttt{bC} (sin cambios)
    \item \texttt{A1C}
    \item \texttt{Ab} (sin cambios)
    \item \texttt{C} (sin cambios)
    \item \texttt{b} (sin cambios)
    \item \texttt{A} (sin cambios)
\end{itemize}

Para el segmento \texttt{AgC}:

\begin{itemize}
    \item \texttt{AgC} (sin cambios)
    \item \texttt{gC} (sin cambios)
    \item \texttt{A1C}
    \item \texttt{Ag} (sin cambios)
    \item \texttt{C} (sin cambios)
    \item \texttt{g} (sin cambios)
    \item \texttt{A} (sin cambios)
\end{itemize}

Nota: No se dio el caso con nuestro ejemplo pero una subsecuencia con múltiples ``x'' como AxxxC pasaría a A3C

\subsection{Comparación de Transformaciones}

Se comparan las subsecuencias de ambos segmentos para identificar patrones comunes. Existen dos casos:

\begin{itemize}
    \item \textbf{Secuencias idénticas}: Las subsecuencias son exactamente iguales.
    \item \textbf{Secuencias similares (sin números)}: Las subsecuencias son iguales si se ignoran los números resultantes de la compresión de \texttt{x(n)}.
\end{itemize}

En nuestro ejemplo, los patrones comunes identificados son:

\begin{itemize}
    \item \texttt{A-x-C}
    \item \texttt{A}
    \item \texttt{C}
\end{itemize}

\subsection{Formateo de Secuencias}

Las secuencias comunes se formatean para resaltar los patrones, siguiendo la notación PA Line.

Aplicando el formateo, obtenemos:

\begin{itemize}
    \item Para \texttt{A x C}: \texttt{A-x(1)-C}
    \item Para \texttt{A}: \texttt{A}
    \item Para \texttt{C}: \texttt{C}
\end{itemize}

\subsection{Asignación de Puntuaciones}

A cada patrón se le asigna una puntuación basada en la siguiente fórmula:

\[
\text{Puntuación} = x + m \times n + y \times n^2
\]

Donde:

\begin{itemize}
    \item $x$: Número de \texttt{x} (gaps) en el patrón.
    \item $m$: Número de letras minúsculas en el patrón.
    \item $y$: Número de letras mayúsculas en el patrón.
    \item $n$: Longitud del segmento original.
\end{itemize}

Para nuestro ejemplo, con segmentos de longitud $n=3$, calculamos las puntuaciones:

\begin{itemize}
    \item \texttt{A-x(1)-C}:
    \begin{itemize}
        \item $x = 1$ (un gap)
        \item $m = 0$ (cero minúsculas)
        \item $y = 2$ (A y C son mayúsculas)
        \item Puntuación: $1 + 0 \times 3 + 2 \times 3^2 = 1 + 0 + 18 = 19$
    \end{itemize}
    \item \texttt{A}:
    \begin{itemize}
        \item $x = 0$
        \item $m = 0$
        \item $y = 1$
        \item Puntuación: $0 + 0 \times 3 + 1 \times 3^2 = 0 + 0 + 9 = 9$
    \end{itemize}
    \item \texttt{C}:
    \begin{itemize}
        \item $x = 0$
        \item $m = 0$
        \item $y = 1$
        \item Puntuación: $0 + 0 \times 3 + 1 \times 3^2 = 0 + 0 + 9 = 9$
    \end{itemize}
\end{itemize}

\subsection{Ordenamiento de Patrones}

Finalmente, se ordenan los patrones según su puntuación de mayor a menor:

\begin{enumerate}
    \item \texttt{A-x(1)-C} ($19$ puntos)
    \item \texttt{A} ($9$ puntos)
    \item \texttt{C} ($9$ puntos)
\end{enumerate}

Siendo el patrón A-x(1)-C el elegido como mejor patrón.


\section{Implementación}

El algoritmo diseñado para descubrir patrones estructurales en proteínas se compone de varios pasos detallados. A continuación, se describe el proceso de implementación junto con el pseudocódigo que ilustra cada parte de la lógica.

\subsection{Generación de Subsecuencias Transformadas}

El algoritmo genera todas las posibles subsecuencias de un segmento de entrada, reemplazando los caracteres por un marcador especial \texttt{x} en todas las combinaciones posibles. Las subsecuencias resultantes se comprimen para representar las \texttt{x} consecutivas como \texttt{x(n)}.

\begin{algorithm}[H]
\caption{Generar secuencias transformadas}
\begin{algorithmic}[1]
\Function{GenerarSecuenciasTransformadas}{secuencia}
    \For{$num \gets 0$ \textbf{to} $2^{largo - 1}$}
        \State $binario \gets \text{convertirAStringBinario}(num, largo)$
        \State $nuevaSecuencia \gets []$
        \For{$i \gets 0$ \textbf{to} $largo - 1$}
            \If{$binario[i] == 1$}
                \State $nuevaSecuencia$.add(\texttt{'x'})
            \Else
                \State $nuevaSecuencia$.add(secuencia[$i$])
            \EndIf
        \EndFor
        \State $subsecuenciaFormateada \gets \text{removerXInicialFinal}(nuevaSecuencia)$
        \State $subsecuenciaFormateada \gets \text{comprimirXConsecutivas}(subsecuenciaFormateada)$
        \If{$subsecuenciaFormateada$ contiene letras mayúsculas}
            \State $subsecuencias$.add($subsecuenciaFormateada$)
        \EndIf
    \EndFor
    \State \Return $subsecuencias$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Comparación de Transformaciones}

Las subsecuencias se comparan para identificar patrones comunes. Se consideran secuencias idénticas y secuencias similares (que ignoran los números en la notación \texttt{x(n)}).

\begin{algorithm}[H]
\caption{Comparar transformaciones}
\begin{algorithmic}[1]
\Function{CompararTransformaciones}{lista1, lista2}
    \State $set1 \gets \text{convertirAConjunto}(lista1)$
    \State $set2 \gets \text{convertirAConjunto}(lista2)$
    \State $patrones \gets []$
    \For{$sub1 \in set1$}
        \If{$sub1 \in set2$}
            \State $patrones$.add(\text{formatearSecuenciaIdentica}($sub1$))
        \Else
            \For{$sub2 \in set2$}
                \If{\text{sonSimilaresSinNumeros}($sub1, sub2$)}
                    \State $patrones$.add(\text{compararSecuencias}($sub1, sub2$))
                \EndIf
            \EndFor
        \EndIf
    \EndFor
    \State \Return $patrones$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Asignación de Puntuaciones}

Cada patrón identificado se evalúa mediante una fórmula de puntuación basada en la presencia de \texttt{x}, letras minúsculas y mayúsculas:

\[
\text{Puntuación} = x + m \times n + y \times n^2
\]

\begin{algorithm}[H]
\caption{Asignar puntuaciones y ordenar}
\begin{algorithmic}[1]
\Function{OrdenarYAsignarPuntuaciones}{patrones, longitudSegmento}
    \State $puntuaciones \gets []$
    \For{$\text{patrón} \in patrones$}
        \State $\text{puntuación} \gets \text{calcularPuntuación}(\text{patrón}, longitudSegmento)$
        \State $puntuaciones$.add($\text{puntuación}$)
    \EndFor
    \State \Return \text{ordenarPorPuntuación}($patrones, puntuaciones$)
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Experimentos}

El algoritmo es efectivo para identificar y resaltar patrones comunes entre dos secuencias de caracteres, permitiendo detectar similitudes y variaciones significativas. Mediante la generación exhaustiva de subsecuencias y su transformación, es posible analizar en profundidad las estructuras de las secuencias y ordenar los patrones según su relevancia, lo cual es útil en diversos campos como bioinformática, análisis de datos y procesamiento de lenguaje natural.


\chapter{Método en paralelo}

\section{Método 1}


\subsection{Diseño}

\subsection{Implementación}

\section{Método 2}

\subsection{Diseño}

\subsection{Implementación}


\section{}

\chapter{Conclusiones}

\chapter{Anexos}


%% ambiente glosario
\begin{glosario}
  \item[El primer término:] Este es el significado del primer término, realmente no se bien lo que significa pero podría haberlo averiguado si hubiese tenido un poco mas de tiempo.
  \item[El segundo término:] Este si se lo que significa pero me da lata escribirlo...
\end{glosario}


%% genera las referencias
\bibliography{refs}


%% comienzo de la parte de anexos
\appendixpart

%% contenido del primer anexo
\appendix{El Primer Anexo}
Aquí va el texto del primer anexo...

\section{La primera sección del primer anexo}
Aquí va el texto de la primera sección del primer anexo...

\section{La segunda sección del primer anexo}
Aquí va el texto de la segunda sección del primer anexo...

\subsection{La primera subsección de la segunda sección del primer anexo}


%% contenido del segundo anexo
\appendix{El segundo Anexo}
Aquí va el texto del segundo anexo...

\section{La primera sección del segundo anexo}
Aquí va el texto de la primera sección del segundo anexo...

%% fin
\end{document}

   

