\chapter{Método secuencial}
%% poner intro
\section{Extracción de datos}

Se desarrolló un algoritmo que permite detectar los aminoácidos que interactúan con los ligandos en una proteína y que retorna los segmentos de la proteína que contienen esos aminoácidos.

Para esto se utilizó la librería \texttt{Biopython} \cite{biopython_articulo}, la cual es una colección de Python disponible gratuitamente módulos para biología molecular computacional, y el paquete Bio.PDB \cite{biopdb} que facilita el uso y procesamiento de los archivos \texttt{.pdb}, que corresponden a archivos del Protein Data Bank (PDB) \cite{pdb}.

\subsection{Descripción del Algoritmo}

El algoritmo se compone de varios pasos que se detallan a continuación, junto con ejemplos aplicados a la proteína \texttt{1znf} para facilitar su comprensión.

\subsubsection{Configuración Inicial}

En esta sección, se establecen los parámetros iniciales y se preparan las estructuras de datos necesarias para el análisis.

\begin{algorithm}[H]
\caption{Proceso de análisis de interacción proteína-ligando}
\begin{algorithmic}[1]
\State Establecer el umbral de distancia para considerar una interacción (\texttt{distance\_threshold})
\State Leer el archivo PDB para obtener la estructura de la proteína
\State Inicializar listas para residuos de ligando (\texttt{ligand\_residues}), átomos de proteína (\texttt{protein\_atoms}) y lista de residuos (\texttt{residues\_list})
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo:}

Para la proteína \texttt{1znf}, se establece un umbral de distancia de 4.0 \AA. Se lee el archivo \texttt{1znf.pdb} y se inicializan las listas vacías para almacenar los residuos de ligando, átomos de proteína y lista de residuos.

\subsubsection{Recopilación de Información de la Estructura}

Se recorre la secuencia para identificar los ligandos y aminoácidos de la proteína, almacenando la información relevante en listas para su posterior procesamiento.

\begin{algorithm}[H]
\caption{Proceso de extracción de ligandos y átomos de proteína}
\begin{algorithmic}[1]
\ForAll{cadena en la estructura}
    \ForAll{residuo en la cadena}
        \State Obtener \texttt{hetfield}, \texttt{resseq} y \texttt{icode} para identificar el residuo
        // hetfield: Indica el tipo de residuo. 
        
        // resseq: Es el número de secuencia del residuo
        
        // icode: Código de inserción.
        
        \State Obtener el nombre del residuo (\texttt{resname})
        \If{el residuo es un ligando}
            \State Añadir el residuo a \texttt{ligand\_residues}
        \ElsIf{el residuo es de proteína}
            \State Añadir los átomos del residuo a \texttt{protein\_atoms}
            \State Añadir el residuo a \texttt{residues\_list}
        \EndIf
    \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo:}

Al procesar la proteína \texttt{1znf}, se identifican los ligandos y de aminoácidos. Los ligandos encontrados son \texttt{NH2}, \texttt{ACE} y \texttt{ZN}, mientras que lo demás corresponde a los aminoácidos de la cadena.

\subsubsection{Detección y Procesamiento de Ligandos}

Se verifica si existen ligandos en la estructura y se procesa cada uno de ellos individualmente.

\begin{algorithm}[H]
\caption{Identificación de aminoácidos interactuantes con ligandos}
\begin{algorithmic}[1]
\If{no se encontraron residuos de ligando}
    \State Terminar el algoritmo
\EndIf
\State Obtener códigos únicos de ligandos (\texttt{ligand\_codes})
\ForAll{código de ligando \texttt{lig\_code} en \texttt{ligand\_codes}}
    \State Obtener los átomos del ligando actual
    \State Proceder con la identificación de aminoácidos interactuantes
\EndFor
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo:}

En la proteína \texttt{1znf}, se encontraron los ligandos \texttt{NH2}, \texttt{ACE} y \texttt{ZN}. El algoritmo procesará cada uno de estos ligandos de forma individual.

\subsubsection{Identificación de Aminoácidos Interactuantes}

Utilizando un algoritmo de búsqueda de vecinos (NeighborSearch), se identifican los aminoácidos de la proteína que interactúan con el ligando, basándose en el umbral de distancia definido. Esto consiste en comparar la distancia de cada átomo del ligando con los átomos de la proteína y determinar si algún átomo del aminoácido está a una distancia menor al umbral. Un residuo se considera interactuante si al menos uno de sus átomos está dentro del umbral de distancia respecto a cualquier átomo del ligando.

\begin{algorithm}[H]
\caption{Búsqueda de residuos interactuantes con ligandos}
\begin{algorithmic}[1]
\State Crear una búsqueda de vecinos (\texttt{NeighborSearch}) con los átomos de proteína
\State Inicializar un conjunto de residuos que interactúan (\texttt{interacting\_residues})
\ForAll{átomo en los átomos del ligando}
    \State Buscar residuos vecinos dentro del umbral de distancia
    \State Añadir estos residuos a \texttt{interacting\_residues}
\EndFor
\end{algorithmic}
\end{algorithm}

\paragraph{Ejemplo: Identificación de Aminoácidos Interactuantes}

Al procesar el ligando \texttt{NH2} de la proteína \texttt{1znf}, el algoritmo identifica los aminoácidos que se encuentran dentro de 4.0 \AA\ de cualquier átomo del ligando. Los aminoácidos identificados corresponden a los aminoácidos \texttt{H}, \texttt{K} y \texttt{N} al final de la secuencia.

\subsubsection{Generación de la Secuencia Modificada}

Se genera la secuencia completa de aminoácidos de la proteína, utilizando letras mayúsculas para los aminoácidos que interactúan con el ligando y minúsculas para los que no.

\begin{algorithm}[H]
\caption{Generación de secuencia resaltada de residuos}
\begin{algorithmic}[1]
\State Inicializar la secuencia resaltada (\texttt{highlighted\_sequence})
\ForAll{residuo en \texttt{residues\_list}}
    \State Obtener el nombre del residuo (\texttt{resname})
    \State Convertir \texttt{resname} a código de una letra (\texttt{one\_letter})
    \If{el residuo está en \texttt{interacting\_residues}}
        \State Convertir \texttt{one\_letter} a mayúscula
    \Else
        \State Convertir \texttt{one\_letter} a minúscula
    \EndIf
    \State Añadir \texttt{one\_letter} a \texttt{highlighted\_sequence}
\EndFor
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo: Generación de la Secuencia Modificada}

Con la secuencia original de la proteína \texttt{1znf}:

\begin{center}
\texttt{ykcglcersfveksalsrhqrvhkn}
\end{center}

Y considerando que los residuos que interactúan con el ligando \texttt{NH2} son \texttt{H}, \texttt{K} y \texttt{N}, la secuencia modificada será:

\begin{center}
\texttt{ykcglcersfveksalsrhqrvHKN}
\end{center}

Las letras mayúsculas indican los aminoácidos que interactúan con el ligando.

\subsubsection{Extracción y Presentación del Segmento Interactuante}

Se extrae el segmento de la secuencia que abarca desde el primer hasta el último aminoácido que interactúa con el ligando.

\begin{algorithm}[H]
\caption{Detección de segmento interactuante en la secuencia resaltada}
\begin{algorithmic}[1]
\State Utilizar una expresión regular para encontrar el segmento que inicia y termina con una letra mayúscula
\If{se encuentra una coincidencia}
    \State Extraer el segmento interactuante (\texttt{interacting\_segment})
    \State Mostrar el segmento interactuante al usuario
\Else
    \State Indicar que no se encontraron residuos que interactúen con el ligando
\EndIf
\end{algorithmic}
\end{algorithm}
 ligando y se muestra al usuario.

\begin{algorithm}[H]
\caption{Detección de segmento interactuante en la secuencia resaltada}
\begin{algorithmic}[1]
\State Utilizar una expresión regular para encontrar el segmento que inicia y termina con una letra mayúscula
\If{se encuentra una coincidencia}
    \State Extraer el segmento interactuante (\texttt{interacting\_segment})
    \State Mostrar el segmento interactuante al usuario
\Else
    \State Indicar que no se encontraron residuos que interactúen con el ligando
\EndIf
\end{algorithmic}
\end{algorithm}


\paragraph{Ejemplo: Extracción y Presentación del Segmento Interactuante}

Aplicando la expresión regular a la secuencia modificada:

\begin{center}
\texttt{ykcglcersfveksalsrhqrvHKN}
\end{center}

Se extrae el segmento que va desde la primera letra mayúscula hasta la última:

\begin{center}
\texttt{HKN}
\end{center}

Este es el segmento de aminoácidos que interactúa con el ligando \texttt{NH2}.
El mismo proceso se repite para los otros ligandos identificados.

\subsection{Construcción de la matriz LCS}

Para cada par de segmentos que interactúan con un ligando se construye una matriz $(n+1) \times (m+1)$ que almacena la longitud de la \textit{Longest Common Subsequence} entre los prefijos de ambas cadenas. La recurrencia empleada es la usual en programación dinámica:

\[
L_{i,j} = 
\begin{cases}
L_{i-1,j-1} + 1 & \text{si } s_i = t_j, \\
\max(L_{i-1,j}, L_{i,j-1}) & \text{en otro caso}.
\end{cases}
\]

Además de la matriz $L$ se mantiene una matriz de direcciones $D$ que registra si la mejor transición proviene de la diagonal, desde arriba o desde la izquierda. Esta información permite reconstruir posteriormente todos los alineamientos que alcanzan la longitud óptima.

Para los segmentos de ejemplo \texttt{AbC} y \texttt{AgC}, la matriz resultante es:

\[
\begin{array}{c|cccc}
   & - & A & g & C \\
\hline
-  & 0 & 0 & 0 & 0 \\
A  & 0 & 1 & 1 & 1 \\
b  & 0 & 1 & 1 & 1 \\
C  & 0 & 1 & 1 & 2 \\
\end{array}
\]

El valor $L_{3,3} = 2$ indica que la LCS tiene longitud dos y que existen coincidencias suficientes para derivar un patrón candidato útil.

\subsection{Recuperación de patrones candidatos}

La reconstrucción de los patrones se realiza mediante un recorrido inverso sobre $D$. Cada vez que existen múltiples direcciones posibles se exploran todas las alternativas para obtener alineamientos diferentes. El proceso genera secuencias intermedias en las que se alternan coincidencias exactas con huecos que representan los aminoácidos no compartidos entre ambas cadenas.

En el ejemplo anterior, el retroceso toma una diagonal al encontrar la coincidencia \texttt{C}, avanza hacia arriba para contabilizar un hueco de longitud uno y finaliza con la coincidencia \texttt{A}. El alineamiento resultante se escribe:
\begin{itemize}
    \item \texttt{A-C}
\end{itemize}

\subsection{Formateo de patrones}

Cada alineamiento se transforma a la notación PA Line de Prosite. Los aminoácidos conservados se expresan con letras mayúsculas y los huecos se convierten en expresiones \texttt{x(n)}, donde $n$ es la longitud del segmento ausente. Utilizando el alineamiento previo se obtiene:

\begin{itemize}
    \item \texttt{A-g-C} $\rightarrow$ \texttt{A-x(1)-C}
    \item \texttt{A} $\rightarrow$ \texttt{A}
    \item \texttt{C} $\rightarrow$ \texttt{C}
\end{itemize}

Además, se define una notación complementaria para los casos en que un patrón presenta segmentos ausentes de longitudes $X_i$ observadas pero no de una longitud $X_j$ determinada. En tales situaciones se registran explícitamente las longitudes detectadas; por ejemplo, la notación

\texttt{A-x(1|2|3|5)-C}

indica que el patrón admite un hueco de longitud 1, 2, 3 o 5, y que no se ha observado un hueco de longitud 4.

\subsection{Asignación de Puntuaciones}

A cada patrón se le asigna una puntuación basada en la siguiente fórmula:

\[
\text{Puntuación} = x + m \times n + y \times n^2
\]

Donde:

\begin{itemize}
    \item $x$: Número de \texttt{x} (gaps) en el patrón.
    \item $m$: Número de letras minúsculas en el patrón.
    \item $y$: Número de letras mayúsculas en el patrón.
    \item $n$: Longitud del segmento original.
\end{itemize}

Para nuestro ejemplo, con segmentos de longitud $n=3$, calculamos las puntuaciones:

\begin{itemize}
    \item \texttt{A-x(1)-C}:
    \begin{itemize}
        \item $x = 1$ (un gap)
        \item $m = 0$ (cero minúsculas)
        \item $y = 2$ (A y C son mayúsculas)
        \item Puntuación: $1 + 0 \times 3 + 2 \times 3^2 = 1 + 0 + 18 = 19$
    \end{itemize}
    \item \texttt{A}:
    \begin{itemize}
        \item $x = 0$
        \item $m = 0$
        \item $y = 1$
        \item Puntuación: $0 + 0 \times 3 + 1 \times 3^2 = 0 + 0 + 9 = 9$
    \end{itemize}
    \item \texttt{C}:
    \begin{itemize}
        \item $x = 0$
        \item $m = 0$
        \item $y = 1$
        \item Puntuación: $0 + 0 \times 3 + 1 \times 3^2 = 0 + 0 + 9 = 9$
    \end{itemize}
\end{itemize}

\subsection{Ordenamiento de Patrones}

Finalmente, se ordenan los patrones según su puntuación de mayor a menor:

\begin{enumerate}
    \item \texttt{A-x(1)-C} ($19$ puntos)
    \item \texttt{A} ($9$ puntos)
    \item \texttt{C} ($9$ puntos)
\end{enumerate}

Siendo el patrón A-x(1)-C el elegido como mejor patrón.


\section{Implementación}

El algoritmo basado en LCS para descubrir patrones proteína-ligando se implementó en tres etapas: construcción de la matriz de programación dinámica, recuperación y formateo de alineamientos. Cada etapa expone puntos de paralelización que permiten distribuir el trabajo entre hilos independientes, ya sea dividiendo la matriz por diagonales o repartiendo los caminos de retroceso entre colas de tareas.

\subsection{Construcción de la matriz LCS}

La primera fase crea las matrices de longitud y de direcciones necesarias para el retroceso posterior. El cálculo se realiza fila a fila respetando las dependencias de la programación dinámica; en la versión paralela se procesan las diagonales de la matriz en paralelo para maximizar el uso de los núcleos disponibles.

\begin{algorithm}[H]
\caption{ConstruirMatricesLCS}
\begin{algorithmic}[1]
\Function{ConstruirMatricesLCS}{secuenciaA, secuenciaB}
    \State $n \gets \text{len}(\text{secuenciaA})$
    \State $m \gets \text{len}(\text{secuenciaB})$
    \State $L \gets \text{matriz}(n+1, m+1, 0)$
    \State $D \gets \text{matriz}(n+1, m+1, \emptyset)$
    \For{$i \gets 1$ \textbf{to} $n$}
        \For{$j \gets 1$ \textbf{to} $m$}
            \If{$\text{secuenciaA}[i-1] = \text{secuenciaB}[j-1]$}
                \State $L[i][j] \gets L[i-1][j-1] + 1$
                \State $D[i][j]$.add(\texttt{DIAGONAL})
            \Else
                \State $arriba \gets L[i-1][j]$
                \State $izquierda \gets L[i][j-1]$
                \State $mejor \gets \max(arriba, izquierda)$
                \State $L[i][j] \gets mejor$
                \If{$arriba = mejor$}
                    \State $D[i][j]$.add(\texttt{ARRIBA})
                \EndIf
                \If{$izquierda = mejor$}
                    \State $D[i][j]$.add(\texttt{IZQUIERDA})
                \EndIf
            \EndIf
        \EndFor
    \EndFor
    \State \Return $(L, D)$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Recuperación y formateo de patrones}

Una vez calculadas las matrices, se realiza el retroceso para reconstruir los alineamientos que alcanzan la longitud óptima. El procedimiento explora todas las trayectorias registradas en $D$ y traduce cada alineamiento en una cadena compatible con la notación PA Line, colapsando los huecos consecutivos en expresiones \texttt{x(n)}. En la implementación paralela, cada hilo procesa una rama diferente del árbol de retroceso para generar los patrones de forma concurrente.

\begin{algorithm}[H]
\caption{RecuperarYFormatearPatrones}
\begin{algorithmic}[1]
\Function{RecuperarYFormatearPatrones}{D, secuenciaA, secuenciaB}
    \State $n \gets \text{len}(\text{secuenciaA})$
    \State $m \gets \text{len}(\text{secuenciaB})$
    \State $patrones \gets \text{conjunto vacío}$
    \State \textsc{Backtrack}($n, m, []$)
    \State \Return $patrones$
\EndFunction
\Procedure{Backtrack}{$i, j, alineacion$}
    \If{$i = 0$ \textbf{or} $j = 0$}
        \State $patron \gets \textsc{Formatear}(alineacion)$
        \If{$patron \neq \varnothing$}
            \State $patrones$.add($patron$)
        \EndIf
        \State \Return
    \EndIf
    \For{$mov \in D[i][j]$}
        \If{$mov = \texttt{DIAGONAL}$}
            \State \textsc{Backtrack}($i-1, j-1, [( \text{secuenciaA}[i-1], \text{secuenciaB}[j-1]) ] + alineacion$)
        \ElsIf{$mov = \texttt{ARRIBA}$}
            \State \textsc{Backtrack}($i-1, j, [( \text{secuenciaA}[i-1], - )] + alineacion$)
        \Else
            \State \textsc{Backtrack}($i, j-1, [(-, \text{secuenciaB}[j-1])] + alineacion$)
        \EndIf
    \EndFor
\EndProcedure
\Function{Formatear}{alineacion}
    \State $resultado \gets []$
    \State $gap \gets 0$
    \State $tieneResiduo \gets \text{falso}$
    \For{$(a, b) \in alineacion$}
        \If{$a = b$ \textbf{and} $a$ es mayúscula}
            \If{$gap > 0$}
                \State $resultado$.add(\texttt{x(}$gap$\texttt{)}) \Comment{Se colapsan huecos consecutivos}
                \State $gap \gets 0$
            \EndIf
            \State $resultado$.add($a$)
            \State $tieneResiduo \gets \text{verdadero}$
        \Else
            \State $gap \gets gap + 1$
        \EndIf
    \EndFor
    \If{$gap > 0$}
        \State $resultado$.add(\texttt{x(}$gap$\texttt{)})
    \EndIf
    \If{$tieneResiduo$}
        \State \Return \text{unir}($resultado$, \texttt{-})
    \EndIf
    \State \Return $\varnothing$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Asignación de Puntuaciones}

Cada patrón recuperado se evalúa mediante la misma función de puntuación empleada en la sección anterior. La fórmula toma como base la cantidad de huecos, letras minúsculas y letras mayúsculas:

\[
\text{Puntuación} = x + m \times n + y \times n^2
\]

\begin{algorithm}[H]
\caption{Asignar puntuaciones y ordenar}
\begin{algorithmic}[1]
\Function{OrdenarYAsignarPuntuaciones}{patrones, longitudSegmento}
    \State $puntuaciones \gets []$
    \For{$\text{patrón} \in patrones$}
        \State $\text{puntuación} \gets \text{calcularPuntuación}(\text{patrón}, longitudSegmento)$
        \State $puntuaciones$.add($\text{puntuación}$)
    \EndFor
    \State \Return \text{ordenarPorPuntuación}($patrones, puntuaciones$)
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Experimentos}

El algoritmo basado en LCS demostró ser efectivo para identificar y resaltar patrones comunes entre dos secuencias de aminoácidos, permitiendo detectar similitudes y variaciones significativas sin incurrir en la explosión combinatoria del enfoque exhaustivo. Al operar sobre la matriz de programación dinámica y reutilizar los alineamientos recuperados, es posible analizar con mayor profundidad las estructuras de las secuencias y ordenar los patrones según su relevancia, lo cual resulta útil en bioinformática, análisis de datos y procesamiento de lenguaje natural.


\chapter{Método en paralelo}

\section{Método 1}


\subsection{Diseño}

\subsection{Implementación}

\section{Método 2}

\subsection{Diseño}

\subsection{Implementación}


\section{}
